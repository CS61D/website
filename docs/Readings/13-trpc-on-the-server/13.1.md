---
title: 13.1 - Defining Routers and Procedures
metadata:
  - Can be provided
  - as: objects
    or: arrays
---

# 13.1 - Defining Routers and Procedures

## Introduction to tRPC

### Overview

tRPC (TypeScript Remote Procedure Call) is a framework that enables building end-to-end type-safe APIs using TypeScript. It allows you to define your API contract using TypeScript types and provides type inference across the client and server. The main goal of tRPC is to eliminate the need for manual API client generation and ensure type safety throughout the development process.

### How it Works

1. **Define Procedures on the Server**: Use TypeScript to define API endpoints (procedures) for queries and mutations.
2. **Generate Type-Safe Client**: tRPC generates a type-safe client that you can use in your frontend code.
3. **Invoke Procedures from the Client**: Call the server-side procedures from the client with full type safety and autocompletion.

### Features

- **Type Safety**: Automatically infers types from your server to your client, reducing the risk of runtime errors.
- **No Schema Definitions**: Unlike GraphQL or REST, tRPC does not require separate schema definitions. It uses TypeScript types directly.
- **Flexible and Lightweight**: Provides a simple API to define and use procedures, making it easy to integrate with existing projects.
- **Middleware Support**: Allows for adding middleware for authentication, authorization, logging, etc.

---

## Defining Routers and Procedures

In tRPC, the two fundamental concepts you'll work with on the server are **routers** and **procedures**.

### Routers

A router in tRPC is a way to group related API procedures, much like a controller in traditional MVC (Model-View-Controller) frameworks. Routers help you organize your API endpoints logically, making your codebase easier to maintain.

#### Example of a Router

Imagine you're building an API for a blogging platform. You might have different routers for handling users, posts, and comments. Here's a basic example:

```typescript
import { router } from "@trpc/server";
import { z } from "zod"; // for input validation

const userRouter = router({
  getUser: procedure.input(z.object({ id: z.string() })).query(({ input }) => {
    // Logic to fetch user by ID
    return getUserFromDatabase(input.id);
  }),

  createUser: procedure
    .input(z.object({ name: z.string(), email: z.string() }))
    .mutation(({ input }) => {
      // Logic to create a new user
      return createUserInDatabase(input);
    }),
});
```

In this example, the `userRouter` contains two procedures: `getUser` and `createUser`. These procedures are defined using tRPC's `procedure` method, and each procedure can have its own input and output types.

### Procedures

Procedures are the actual endpoints in your API. They represent a specific piece of functionality that your frontend can call, like fetching data or creating a new resource. Procedures in tRPC are type-safe, meaning the input and output are strongly typed.

#### Types of Procedures

- **Queries**: Used for fetching data without causing side effects. For example, getting a user's profile or retrieving a list of posts.

- **Mutations**: Used for operations that modify data on the server. For example, creating a new post, updating user information, or deleting a comment.

#### Example of Procedures

Continuing with the blogging platform example, let's add some procedures to handle posts:

```typescript
const postRouter = router({
  getPost: procedure.input(z.object({ id: z.string() })).query(({ input }) => {
    // Logic to fetch a post by ID
    return getPostFromDatabase(input.id);
  }),

  createPost: procedure
    .input(z.object({ title: z.string(), content: z.string() }))
    .mutation(({ input }) => {
      // Logic to create a new post
      return createPostInDatabase(input);
    }),
});
```

---
